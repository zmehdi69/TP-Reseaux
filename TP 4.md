# TP4 : TCP, UDP et services rÃ©seau

Dans ce TP on va explorer un peu les protocoles TCP et UDP. 

**La premiÃ¨re partie est dÃ©tente**, vous explorez TCP et UDP un peu, en vous servant de votre PC.

La seconde partie se dÃ©roule en environnement virtuel, avec des VMs. Les VMs vont nous permettre en place des services rÃ©seau, qui reposent sur TCP et UDP.  
**Le but est donc de commencer Ã  mettre les mains de plus en plus du cÃ´tÃ© administration, et pas simple client.**

Dans cette seconde partie, vous Ã©tudierez donc :

- le protocole SSH (contrÃ´le de machine Ã  distance)
- le protocole DNS (rÃ©solution de noms)
  - essentiel au fonctionnement des rÃ©seaux modernes

![TCP UDP](./pics/tcp_udp.jpg)

# Sommaire

- [TP4 : TCP, UDP et services rÃ©seau](#tp4--tcp-udp-et-services-rÃ©seau)
- [Sommaire](#sommaire)
- [0. PrÃ©requis](#0-prÃ©requis)
- [I. First steps](#i-first-steps)
- [II. Mise en place](#ii-mise-en-place)
  - [1. SSH](#1-ssh)
  - [2. Routage](#2-routage)
- [III. DNS](#iii-dns)
  - [1. PrÃ©sentation](#1-prÃ©sentation)
  - [2. Setup](#2-setup)
  - [3. Test](#3-test)

# 0. PrÃ©requis

âœ Pour ce TP, on va se servir de VMs Rocky Linux. On va en faire plusieurs, n'hÃ©sitez pas Ã  diminuer la RAM (512Mo ou 1Go devraient suffire). Vous pouvez redescendre la mÃ©moire vidÃ©o aussi.  

âœ Si vous voyez un ğŸ¦ˆ c'est qu'il y a un PCAP Ã  produire et Ã  mettre dans votre dÃ©pÃ´t git de rendu

âœ **L'emoji ğŸ–¥ï¸ indique une VM Ã  crÃ©er**. Pour chaque VM, vous dÃ©roulerez la checklist suivante :

- [x] CrÃ©er la machine (avec une carte host-only)
- [ ] DÃ©finir une IP statique Ã  la VM
- [ ] Donner un hostname Ã  la machine
- [ ] VÃ©rifier que l'accÃ¨s SSH fonctionnel
- [ ] VÃ©rifier que le firewall est actif
- [ ] Remplir votre fichier `hosts`, celui de votre PC, pour accÃ©der au VM avec un nom
- [ ] DÃ¨s que le routeur est en place, n'oubliez pas d'ajouter une route par dÃ©faut aux autres VM pour qu'elles aient internet

> Toutes les commandes pour rÃ©aliser ces opÃ©rations sont dans [le mÃ©mo Rocky](../../cours/memo/rocky_network.md). Aucune de ces Ã©tapes ne doit figurer dan le rendu, c'est juste la mise en place de votre environnement de travail.

# I. First steps

Faites-vous un petit top 5 des applications que vous utilisez sur votre PC souvent, des applications qui utilisent le rÃ©seau : un site que vous visitez souvent, un jeu en ligne, Spotify, j'sais po moi, n'importe.

ğŸŒ **DÃ©terminez, pour ces 5 applications, si c'est du TCP ou de l'UDP**

- avec Wireshark, on va faire les chirurgiens rÃ©seau
- dÃ©terminez, pour chaque application :
  - IP et port du serveur auquel vous vous connectez
  - le port local que vous ouvrez pour vous connecter
```
Netflix (TCP) : 
    - IP : 92.90.254.205
    - Port serveur : 443
    - Port local : 60204
```

```
Spotify (TCP) :
    - IP : 35.186.224.25
    - Port serveur : 443
    - Port local : 61689
```
```
Overwatch 2 (UDP) :
    - IP : 5.42.191.126
    - Port serveur : 26544
    - Port local : 60037
```
```
Discord (TCP) :
    - IP : 162.159.137.232
    - Port serveur : 443
    - Port local : 26523
```

```
Youtube (UDP) :
    - IP : 91.68.245.13
    - Port serveur : 443
    - Port local : 55723
```

ğŸŒ **Demandez l'avis Ã  votre OS**

- votre OS est responsable de l'ouverture des ports, et de placer un programme en "Ã©coute" sur un port
- il est aussi responsable de l'ouverture d'un port quand une application demande Ã  se connecter Ã  distance vers un serveur
- bref il voit tout quoi
- utilisez la commande adaptÃ©e Ã  votre OS pour repÃ©rer, dans la liste de toutes les connexions rÃ©seau Ã©tablies, la connexion que vous voyez dans Wireshark, pour chacune des 5 applications

**Il faudra ajouter des options adaptÃ©es aux commandes pour y voir clair. Pour rappel, vous cherchez des connexions TCP ou UDP.**

Netflix :
```
PS C:\Users\Zahreddine Mehdi> netstat -n
```
```
Connexions actives

Proto  Adresse locale         Adresse distante       Ã‰tat
TCP    10.33.19.192:60252     92.90.254.205:443      ESTABLISHED
```
[capture de trames de l'appli Netflix](capturenetflix.pcapng)

Spotify :
```
PS C:\Users\Zahreddine Mehdi> netstat -n
```
```
Connexions actives

Proto  Adresse locale         Adresse distante       Ã‰tat
TCP    10.33.19.192:60537     35.186.224.25:443      ESTABLISHED
```
[capture de trames de l'appli Spotify](capturespotify.pcapng)

Overwatch 2 :
```
PS C:\Windows\system32> netstat -n -p udp -a -b
```
```
Connexions actives

Proto  Adresse locale         Adresse distante       Ã‰tat
 UDP    0.0.0.0:60037          *:*
[Overwatch.exe]
```
[capture de trames de l'appli Overwatch](captureoverwatch.pcapng)

Discord :
```
PS C:\Windows\system32> netstat -b -n  -p tcp
```
```
Connexions actives

Proto  Adresse locale         Adresse distante       Ã‰tat
 TCP   10.33.19.192:64411     162.159.136.234:443    ESTABLISHED
[Discord.exe]
```
[capture de trames de l'appli Discord](capturediscord.pcapng)

Youtube :
```
PS C:\Windows\system32> netstat -n -p udp -a -b
```
```
Connexions actives

Proto  Adresse locale         Adresse distante       Ã‰tat
  UDP   0.0.0.0:55723          *:*
[chrome.exe]
```
[capture de trames de l'appli Youtube](captureyoutube.pcapng)

# II. Mise en place

## 1. SSH

ğŸ–¥ï¸ **Machine `node1.tp4.b1`**

- n'oubliez pas de dÃ©rouler la checklist (voir [les prÃ©requis du TP](#0-prÃ©requis))
- donnez lui l'adresse IP `10.4.1.11/24`

Connectez-vous en SSH Ã  votre VM.

ğŸŒ **Examinez le trafic dans Wireshark**

- **dÃ©terminez si SSH utilise TCP ou UDP**
  - pareil rÃ©flÃ©chissez-y deux minutes, logique qu'on utilise pas UDP non ?
- **repÃ©rez le *3-Way Handshake* Ã  l'Ã©tablissement de la connexion**
  - c'est le `SYN` `SYNACK` `ACK`
- **repÃ©rez du trafic SSH**
- **repÃ©rez le FIN ACK Ã  la fin d'une connexion**
- entre le *3-way handshake* et l'Ã©change `FIN`, c'est juste une bouillie de caca chiffrÃ©, dans un tunnel TCP

> **SUR WINDOWS, pour cette Ã©tape uniquement**, utilisez Git Bash et PAS Powershell. Avec Powershell il sera trÃ¨s difficile d'observer le FIN ACK.

ğŸŒ **Demandez aux OS**

- repÃ©rez, avec une commande adaptÃ©e (`netstat` ou `ss`), la connexion SSH depuis votre machine
- ET repÃ©rez la connexion SSH depuis votre VM

ğŸ¦ˆ **Je veux une capture clean avec le 3-way handshake, un peu de trafic au milieu et une fin de connexion**

## 2. Routage

Ouais, un peu de rÃ©pÃ©tition, Ã§a fait jamais de mal. On va crÃ©er une machine qui sera notre routeur, et **permettra Ã  toutes les autres machines du rÃ©seau d'avoir Internet.**

ğŸ–¥ï¸ **Machine `router.tp4.b1`**

- n'oubliez pas de dÃ©rouler la checklist (voir [les prÃ©requis du TP](#0-prÃ©requis))
- donnez lui l'adresse IP `10.4.1.254/24` sur sa carte host-only
- ajoutez-lui une carte NAT, qui permettra de donner Internet aux autres machines du rÃ©seau
- rÃ©fÃ©rez-vous au TP prÃ©cÃ©dent

> Rien Ã  remettre dans le compte-rendu pour cette partie.

# III. DNS

## 1. PrÃ©sentation

Un serveur DNS est un serveur qui est capable de rÃ©pondre Ã  des requÃªtes DNS.

Une requÃªte DNS est la requÃªte effectuÃ©e par une machine lorsqu'elle souhaite connaÃ®tre l'adresse IP d'une machine, lorsqu'elle connaÃ®t son nom.

Par exemple, si vous ouvrez un navigateur web et saisissez `https://www.google.com` alors une requÃªte DNS est automatiquement effectuÃ©e par votre PC pour dÃ©terminez Ã  quelle adresse IP correspond le nom `www.google.com`.

> La partie `https://` ne fait pas partie du nom de domaine, Ã§a indique simplement au navigateur la mÃ©thode de connexion. Ici, c'est HTTPS.

Dans cette partie, on va monter une VM qui porte un serveur DNS. Ce dernier rÃ©pondra aux autres VMs du LAN quand elles auront besoin de connaÃ®tre des noms. Ainsi, ce serveur pourra :

- rÃ©soudre des noms locaux
  - vous pourrez `ping node1.tp4.b1` et Ã§a fonctionnera
  - mais aussi `ping www.google.com` et votre serveur DNS sera capable de le rÃ©soudre aussi

*Dans la vraie vie, il n'est pas rare qu'une entreprise gÃ¨re elle-mÃªme ses noms de domaine, voire gÃ¨re elle-mÃªme son serveur DNS. C'est donc du savoir rÃ©-utilisable pour tous qu'on voit ici.*

> En rÃ©alitÃ©, ce n'est pas votre serveur DNS qui pourra rÃ©soudre `www.google.com`, mais il sera capable de *forward* (faire passer) votre requÃªte Ã  un autre serveur DNS qui lui, connaÃ®t la rÃ©ponse.

![Haiku DNS](./pics/haiku_dns.png)

## 2. Setup

ğŸ–¥ï¸ **Machine `dns-server.tp4.b1`**

- n'oubliez pas de dÃ©rouler la checklist (voir [les prÃ©requis du TP](#0-prÃ©requis))
- donnez lui l'adresse IP `10.4.1.201/24`

Installation du serveur DNS :

```bash
# assurez-vous que votre machine est Ã  jour
$ sudo dnf update -y

# installation du serveur DNS, son p'tit nom c'est BIND9
$ sudo dnf install -y bind bind-utils
```

La configuration du serveur DNS va se faire dans 3 fichiers essentiellement :

- **un fichier de configuration principal**
  - `/etc/named.conf`
  - on dÃ©finit les trucs gÃ©nÃ©raux, comme les adresses IP et le port oÃ¹ on veu Ã©couter
  - on dÃ©finit aussi un chemin vers les autres fichiers, les fichiers de zone
- **un fichier de zone**
  - `/var/named/tp4.b1.db`
  - je vous prÃ©viens, la syntaxe fait mal
  - on peut y dÃ©finir des correspondances `IP ---> nom`
- **un fichier de zone inverse**
  - `/var/named/tp4.b1.rev`
  - on peut y dÃ©finir des correspondances `nom ---> IP`

âœ **Allooooons-y, fichier de conf principal**

```bash
# Ã©ditez le fichier de config principal pour qu'il ressemble Ã  :
$ sudo cat /etc/named.conf
options {
        listen-on port 53 { 127.0.0.1; any; };
        listen-on-v6 port 53 { ::1; };
        directory       "/var/named";
[...]
        allow-query     { localhost; any; };
        allow-query-cache { localhost; any; };

        recursion yes;
[...]
# rÃ©fÃ©rence vers notre fichier de zone
zone "tp4.b1" IN {
     type master;
     file "tp4.b1.db";
     allow-update { none; };
     allow-query {any; };
};
# rÃ©fÃ©rence vers notre fichier de zone inverse
zone "1.4.10.in-addr.arpa" IN {
     type master;
     file "tp4.b1.rev";
     allow-update { none; };
     allow-query { any; };
};
```

âœ **Et pour les fichiers de zone**

```bash
# Fichier de zone pour nom -> IP

$ sudo cat /var/named/tp4.b1.db

$TTL 86400
@ IN SOA dns-server.tp4.b1. admin.tp4.b1. (
    2019061800 ;Serial
    3600 ;Refresh
    1800 ;Retry
    604800 ;Expire
    86400 ;Minimum TTL
)

; Infos sur le serveur DNS lui mÃªme (NS = NameServer)
@ IN NS dns-server.tp4.b1.

; Enregistrements DNS pour faire correspondre des noms Ã  des IPs
dns-server IN A 10.4.1.201
node1      IN A 10.4.1.11
```

```bash
# Fichier de zone inverse pour IP -> nom

$ sudo cat /var/named/tp4.b1.rev

$TTL 86400
@ IN SOA dns-server.tp4.b1. admin.tp4.b1. (
    2019061800 ;Serial
    3600 ;Refresh
    1800 ;Retry
    604800 ;Expire
    86400 ;Minimum TTL
)

; Infos sur le serveur DNS lui mÃªme (NS = NameServer)
@ IN NS dns-server.tp4.b1.

;Reverse lookup for Name Server
201 IN PTR dns-server.tp4.b1.
11 IN PTR node1.tp4.b1.
```

âœ **Une fois ces 3 fichiers en place, dÃ©marrez le service DNS**

```bash
# DÃ©marrez le service tout de suite
$ sudo systemctl start named

# Faire en sorte que le service dÃ©marre tout seul quand la VM s'allume
$ sudo systemctl enable named

# Obtenir des infos sur le service
$ sudo systemctl status named

# Obtenir des logs en cas de probÃ¨me
$ sudo journalctl -xe -u named
```

ğŸŒ **Dans le rendu, je veux**

- un `cat` des fichiers de conf
- un `systemctl status named` qui prouve que le service tourne bien
- une commande `ss` qui prouve que le service Ã©coute bien sur un port

ğŸŒ **Ouvrez le bon port dans le firewall**

- grÃ¢ce Ã  la commande `ss` vous devrez avoir repÃ©rÃ© sur quel port tourne le service
  - vous l'avez Ã©crit dans la conf aussi toute faÃ§on :)
- ouvrez ce port dans le firewall de la machine `dns-server.tp4.b1` (voir le mÃ©mo rÃ©seau Rocky)

## 3. Test

ğŸŒ **Sur la machine `node1.tp4.b1`**

- configurez la machine pour qu'elle utilise votre serveur DNS quand elle a besoin de rÃ©soudre des noms
- assurez vous que vous pouvez :
  - rÃ©soudre des noms comme `node1.tp4.b1` et `dns-server.tp4.b1`
  - mais aussi des noms comme `www.google.com`

ğŸŒ **Sur votre PC**

- utilisez une commande pour rÃ©soudre le nom `node1.tp4.b1` en utilisant `10.4.1.201` comme serveur DNS

> Le fait que votre serveur DNS puisse rÃ©soudre un nom comme `www.google.com`, Ã§a s'appelle la rÃ©cursivitÃ© et c'est activÃ© avec la ligne `recursion yes;` dans le fichier de conf.

ğŸ¦ˆ **Capture d'une requÃªte DNS vers le nom `node1.tp4.b1` ainsi que la rÃ©ponse**